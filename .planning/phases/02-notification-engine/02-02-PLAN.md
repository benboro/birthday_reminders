---
phase: 02-notification-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - BirthdayReminders/Views/Settings/NotificationSettingsView.swift
  - BirthdayReminders/Views/Components/SettingsPlaceholderView.swift
  - BirthdayReminders/Views/BirthdayList/BirthdayListView.swift
  - BirthdayReminders/Services/ContactSyncService.swift
autonomous: true

must_haves:
  truths:
    - "User can open Settings and change the notification delivery time using a time picker"
    - "Changing the delivery time immediately reschedules all notifications at the new time"
    - "After a contact re-import, notifications are rescheduled to include new contacts"
    - "Settings screen shows notification status and links to system Settings when permission is denied"
  artifacts:
    - path: "BirthdayReminders/Views/Settings/NotificationSettingsView.swift"
      provides: "Delivery time picker with @AppStorage binding and reschedule trigger"
      exports: ["NotificationSettingsView"]
    - path: "BirthdayReminders/Views/Components/SettingsPlaceholderView.swift"
      provides: "Updated settings view integrating notification settings section"
    - path: "BirthdayReminders/Views/BirthdayList/BirthdayListView.swift"
      provides: "Settings navigation passes notificationScheduler"
  key_links:
    - from: "BirthdayReminders/Views/Settings/NotificationSettingsView.swift"
      to: "NotificationScheduler.reschedule"
      via: "onChange of delivery time triggers reschedule"
      pattern: "onChange.*notificationHour|notificationMinute.*reschedule"
    - from: "BirthdayReminders/Views/Components/SettingsPlaceholderView.swift"
      to: "NotificationSettingsView"
      via: "Section in settings list"
      pattern: "NotificationSettingsView"
    - from: "BirthdayReminders/Services/ContactSyncService.swift"
      to: "Notification rescheduling"
      via: "onImportComplete callback"
      pattern: "onImportComplete|reschedule"
---

<objective>
Add the user-facing notification delivery time settings and ensure all data-change events trigger notification rescheduling. The settings screen replaces the current placeholder with a full notification configuration section including a time picker and permission status display.

Purpose: Users need to control when they receive notifications, and the system must stay in sync whenever data changes (not just on foreground).
Output: Settings screen with delivery time picker, automatic rescheduling after import and settings changes.
</objective>

<execution_context>
@C:/Users/bmbor/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/bmbor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-notification-engine/02-RESEARCH.md
@.planning/phases/02-notification-engine/02-01-SUMMARY.md

@BirthdayReminders/Views/Components/SettingsPlaceholderView.swift
@BirthdayReminders/Views/BirthdayList/BirthdayListView.swift
@BirthdayReminders/Services/ContactSyncService.swift
@BirthdayReminders/App/BirthdayRemindersApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification delivery time settings view</name>
  <files>
    BirthdayReminders/Views/Settings/NotificationSettingsView.swift
  </files>
  <action>
Create NotificationSettingsView.swift in a new Views/Settings/ directory.

This view is a reusable Section or standalone component that provides:

1. **Delivery time picker:**
   - `@AppStorage("notificationHour") private var notificationHour: Int = 9`
   - `@AppStorage("notificationMinute") private var notificationMinute: Int = 0`
   - A computed `Binding<Date>` property `deliveryTime` that bridges hour/minute integers to a Date for SwiftUI DatePicker (see research Pattern: DatePicker for Notification Delivery Time)
   - `DatePicker("Delivery Time", selection: deliveryTime, displayedComponents: .hourAndMinute)` -- this handles 12h/24h locale automatically
   - Label the section "Notifications"

2. **Permission status display:**
   - Accept `notificationScheduler: NotificationScheduler` as a parameter
   - On `.task`, call `await notificationScheduler.checkStatus()` and store the result in `@State var authStatus: UNAuthorizationStatus?`
   - Show a row with current permission status:
     - `.authorized`: "Notifications Enabled" with green checkmark
     - `.denied`: "Notifications Disabled" with a "Open Settings" button that calls `UIApplication.shared.open(URL(string: UIApplication.openSettingsURLString)!)` to take user to app settings
     - `.notDetermined`: "Notifications Not Set Up" with an "Enable" button that calls `await notificationScheduler.requestPermission()` and refreshes the status
   - Use `@preconcurrency import UserNotifications` for `UNAuthorizationStatus`

3. **Rescheduling on time change:**
   - Accept `@Environment(\.modelContext) private var modelContext`
   - Use `.onChange(of: notificationHour)` and `.onChange(of: notificationMinute)` to trigger rescheduling
   - In the onChange handler: fetch all Person records via `FetchDescriptor<Person>()`, call `await notificationScheduler.reschedule(people:deliveryHour:deliveryMinute:)` with the new values
   - Debounce is not needed because the DatePicker commits on dismiss, not on every scroll tick
  </action>
  <verify>
- NotificationSettingsView.swift exists in Views/Settings/
- Uses @AppStorage for notificationHour (default 9) and notificationMinute (default 0)
- DatePicker with .hourAndMinute displayedComponents
- Permission status row with conditional UI for authorized/denied/notDetermined
- onChange handlers for both hour and minute trigger reschedule
- Uses @preconcurrency import UserNotifications
  </verify>
  <done>
User can pick a delivery time from a native time picker. Changing the time immediately reschedules all notifications at the new hour/minute. Permission status is visible with appropriate actions (open Settings if denied, enable button if not determined).
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate settings view and add post-import rescheduling</name>
  <files>
    BirthdayReminders/Views/Components/SettingsPlaceholderView.swift
    BirthdayReminders/Views/BirthdayList/BirthdayListView.swift
    BirthdayReminders/Services/ContactSyncService.swift
  </files>
  <action>
Update SettingsPlaceholderView.swift:
- Rename the struct from `SettingsPlaceholderView` to `SettingsView` (no longer a placeholder -- Phase 2 fulfills it). Keep the file at the same path to minimize churn; rename the file if desired but the struct name matters more.
- Add `let notificationScheduler: NotificationScheduler` parameter
- Keep the existing "Contacts" section with the re-import button as-is
- After a successful re-import (where `lastImportCount` is set), trigger notification rescheduling: read `notificationHour` and `notificationMinute` from `UserDefaults.standard` (keys "notificationHour" defaulting to 9, "notificationMinute" defaulting to 0), fetch all Person records, and call `await notificationScheduler.reschedule(people:deliveryHour:deliveryMinute:)`
- Add a second section by embedding `NotificationSettingsView(notificationScheduler: notificationScheduler)` below the Contacts section. NotificationSettingsView should render as a Section so it fits naturally in the List.
- Update navigationTitle to "Settings" (already is)

Update BirthdayListView.swift:
- Add `let notificationScheduler: NotificationScheduler` parameter to the view
- Pass `notificationScheduler` through to SettingsView (renamed from SettingsPlaceholderView) in the settings navigation destination
- The toolbar gear icon navigation should pass the scheduler to the settings view

Update ContactSyncService.swift:
- Add an optional callback property: `var onImportComplete: ((_ importedCount: Int) async -> Void)?`
- At the end of `importContacts(into:)`, after `context.save()` and logging, call `await onImportComplete?(importedCount)` if it exists
- This allows the app root to wire up rescheduling after any import, not just the re-import button in settings. The settings re-import button can also use this instead of inline rescheduling.

Wire up in BirthdayRemindersApp.swift (if not already done by Plan 01):
- Set `syncService.onImportComplete` in the app init or body to trigger rescheduling. Something like:
  ```
  syncService.onImportComplete = { [notificationScheduler, container] _ in
      let people = try? container.mainContext.fetch(FetchDescriptor<Person>())
      let hour = UserDefaults.standard.integer(forKey: "notificationHour")
      let minute = UserDefaults.standard.integer(forKey: "notificationMinute")
      await notificationScheduler.reschedule(people: people ?? [], deliveryHour: hour == 0 ? 9 : hour, deliveryMinute: minute)
  }
  ```
  Note: If the app entry point was already fully wired in Plan 01, this is the incremental addition. Only modify BirthdayRemindersApp.swift if needed for the onImportComplete wiring.
  </action>
  <verify>
- SettingsPlaceholderView renamed to SettingsView with notification section
- NotificationSettingsView embedded in settings list
- BirthdayListView accepts and passes notificationScheduler
- ContactSyncService has onImportComplete callback
- Re-import triggers notification rescheduling
- All Person fetches use FetchDescriptor (not hardcoded data)
- UserDefaults keys "notificationHour" and "notificationMinute" match @AppStorage keys in NotificationSettingsView
  </verify>
  <done>
Settings screen has both Contacts and Notifications sections. Delivery time changes trigger immediate rescheduling. Contact re-import triggers rescheduling. The onImportComplete callback enables any import source (onboarding or settings) to trigger notification refresh without duplicating scheduling logic.
  </done>
</task>

</tasks>

<verification>
1. Settings screen: Contacts section (re-import) + Notifications section (time picker + status)
2. Changing delivery time reschedules all notifications at the new time
3. Re-importing contacts reschedules notifications to include new contacts
4. Permission status accurately reflects current state and provides actionable recovery (Open Settings for denied)
5. @AppStorage keys for hour/minute are consistent across all usages ("notificationHour", "notificationMinute")
6. No hardcoded delivery times -- always reads from @AppStorage/UserDefaults
</verification>

<success_criteria>
- Settings screen replaces placeholder with full notification configuration
- Delivery time picker uses DatePicker with .hourAndMinute
- Notification rescheduling triggered by: delivery time change, contact re-import, and scenePhase (from Plan 01)
- Permission status visible in settings with Open Settings link for denied state
- All @AppStorage keys consistent with Plan 01 defaults (hour: 9, minute: 0)
</success_criteria>

<output>
After completion, create `.planning/phases/02-notification-engine/02-02-SUMMARY.md`
</output>
