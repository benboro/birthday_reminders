---
phase: 02-notification-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - BirthdayReminders/Services/NotificationScheduler.swift
  - BirthdayReminders/Services/NotificationDelegate.swift
  - BirthdayReminders/Extensions/Logger+App.swift
  - BirthdayReminders/Views/Onboarding/NotificationPermissionView.swift
  - BirthdayReminders/Views/Onboarding/OnboardingFlowView.swift
  - BirthdayReminders/App/BirthdayRemindersApp.swift
  - BirthdayReminders/Info.plist
autonomous: true

must_haves:
  truths:
    - "User sees a pre-permission primer screen explaining notification value before the system alert appears"
    - "User receives a notification on the day of a contact's birthday at the configured time"
    - "User receives a notification the day before a contact's birthday at the configured time"
    - "App schedules up to 64 notifications prioritized by nearest birthday, covering at most 32 contacts"
    - "App reschedules all notifications when returning to foreground, backfilling freed slots"
    - "Notifications display in the foreground with banner and sound"
  artifacts:
    - path: "BirthdayReminders/Services/NotificationScheduler.swift"
      provides: "Actor-isolated notification scheduling with 64-notification ceiling management"
      exports: ["NotificationScheduler"]
    - path: "BirthdayReminders/Services/NotificationDelegate.swift"
      provides: "UNUserNotificationCenterDelegate for foreground display and tap handling"
      exports: ["NotificationDelegate"]
    - path: "BirthdayReminders/Views/Onboarding/NotificationPermissionView.swift"
      provides: "Pre-permission primer screen with Enable and Skip options"
      exports: ["NotificationPermissionView"]
    - path: "BirthdayReminders/App/BirthdayRemindersApp.swift"
      provides: "ScenePhase-triggered rescheduling and delegate wiring"
    - path: "BirthdayReminders/Extensions/Logger+App.swift"
      provides: "Logger.notifications category"
  key_links:
    - from: "BirthdayReminders/App/BirthdayRemindersApp.swift"
      to: "NotificationScheduler.reschedule"
      via: "scenePhase .active observer"
      pattern: "onChange.*scenePhase.*reschedule"
    - from: "BirthdayReminders/Services/NotificationScheduler.swift"
      to: "UNUserNotificationCenter"
      via: "add(request) calls"
      pattern: "center\\.add"
    - from: "BirthdayReminders/Views/Onboarding/OnboardingFlowView.swift"
      to: "NotificationPermissionView"
      via: "new onboarding step after import"
      pattern: "notificationPermission"
    - from: "BirthdayReminders/App/BirthdayRemindersApp.swift"
      to: "NotificationDelegate"
      via: "delegate assignment in init"
      pattern: "delegate.*=.*notificationDelegate"
---

<objective>
Build the notification engine core: the NotificationScheduler actor that manages the iOS 64-notification ceiling with priority-based scheduling, the NotificationDelegate for foreground display, the pre-permission primer screen integrated into onboarding, and scenePhase-triggered rescheduling wired into the app root.

Purpose: This is the core value proposition of the app -- without notifications, the birthday list is just a passive directory.
Output: Working notification scheduling that fires day-of and day-before notifications at a default 9:00 AM delivery time, with a primer screen in onboarding and automatic rescheduling on every foreground entry.
</objective>

<execution_context>
@C:/Users/bmbor/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/bmbor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-notification-engine/02-RESEARCH.md

@BirthdayReminders/App/BirthdayRemindersApp.swift
@BirthdayReminders/Models/Person.swift
@BirthdayReminders/Services/BirthdayCalculator.swift
@BirthdayReminders/Extensions/Logger+App.swift
@BirthdayReminders/Views/Onboarding/OnboardingFlowView.swift
@BirthdayReminders/Info.plist
</context>

<tasks>

<task type="auto">
  <name>Task 1: NotificationScheduler actor, NotificationDelegate, and Logger extension</name>
  <files>
    BirthdayReminders/Services/NotificationScheduler.swift
    BirthdayReminders/Services/NotificationDelegate.swift
    BirthdayReminders/Extensions/Logger+App.swift
  </files>
  <action>
Create NotificationScheduler.swift as a Swift actor with these responsibilities:

1. **Permission management:**
   - `checkStatus() async -> UNAuthorizationStatus` -- returns current notification authorization status
   - `requestPermission() async -> Bool` -- calls `center.requestAuthorization(options: [.alert, .sound, .badge])`, returns whether granted. If status is `.denied`, return false without calling requestAuthorization (the system dialog won't show again). Log all outcomes.

2. **Scheduling:**
   - `reschedule(people: [Person], deliveryHour: Int, deliveryMinute: Int) async` -- the main scheduling method:
     a. Call `center.removeAllPendingNotificationRequests()` first
     b. Check authorization status -- if not `.authorized`, log and return early
     c. Sort people by `daysUntilBirthday` ascending
     d. For each person, generate up to 2 requests (day-of and day-before), capping total at 64
     e. For day-before: compute target date via `Calendar.current.date(byAdding: .day, value: -1, to: nextBirthdayDate)`. If target date is in the past (before start of today), skip this notification
     f. For day-of: if the birthday is today AND the delivery time has already passed today, skip it (notification would never fire)
     g. Use deterministic IDs: `"\(person.contactIdentifier)-birthday-dayof"` and `"\(person.contactIdentifier)-birthday-daybefore"`
     h. Use `UNCalendarNotificationTrigger` with DateComponents including year, month, day, hour, minute. Use `Calendar.current` for all date math (inherits user timezone per research pitfall 2)
     i. Set `repeats: false` on all triggers
     j. Notification content: day-of title = "\(person.displayName)'s Birthday!", body = "Today is \(person.displayName)'s birthday!". Day-before title = "Birthday Tomorrow", body = "\(person.displayName)'s birthday is tomorrow!". Set `.sound = .default`
     k. Store `contactIdentifier` in `userInfo["contactIdentifier"]` for future tap navigation
     l. Log scheduled count at the end

   - Use `@preconcurrency import UserNotifications` at the top of the file for Swift 6 compatibility
   - The actor holds `private let center = UNUserNotificationCenter.current()`

3. **Private helper:**
   - `private func makeRequest(person: Person, offsetDays: Int, hour: Int, minute: Int) -> UNNotificationRequest?` -- returns nil if the computed target date is in the past. Uses `BirthdayCalculator.nextBirthday(month:day:)` to get the next birthday date, then adds offsetDays via Calendar

Create NotificationDelegate.swift:
- `@preconcurrency import UserNotifications`
- `final class NotificationDelegate: NSObject, UNUserNotificationCenterDelegate, Sendable`
- `nonisolated func userNotificationCenter(_:willPresent:) async -> UNNotificationPresentationOptions` returning `[.banner, .sound, .list]` (NOT .alert -- deprecated)
- `nonisolated func userNotificationCenter(_:didReceive:) async` -- log the tap, extract contactIdentifier from userInfo. Navigation will be wired in a future phase.

Update Logger+App.swift:
- Add `static let notifications = Logger(subsystem: "com.birthdayreminders", category: "notifications")` to the existing Logger extension

All logging of person names MUST use `privacy: .private` per SECR-04.
  </action>
  <verify>
File compiles conceptually (no Xcode on Windows -- verify structure):
- NotificationScheduler.swift exists with actor keyword, reschedule method, 64-cap logic, deterministic IDs
- NotificationDelegate.swift exists with nonisolated delegate methods, returns [.banner, .sound, .list]
- Logger+App.swift has .notifications static property
- All files use @preconcurrency import UserNotifications
- No .alert in presentation options (deprecated)
- No repeating triggers
- All person name logging uses privacy: .private
  </verify>
  <done>
NotificationScheduler actor can schedule up to 64 priority-sorted notifications with day-of and day-before for each contact, using deterministic IDs and calendar triggers at a configurable delivery time. NotificationDelegate displays notifications as banners when app is in foreground. Logger.notifications category exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pre-permission primer, onboarding integration, and app wiring</name>
  <files>
    BirthdayReminders/Views/Onboarding/NotificationPermissionView.swift
    BirthdayReminders/Views/Onboarding/OnboardingFlowView.swift
    BirthdayReminders/App/BirthdayRemindersApp.swift
    BirthdayReminders/Info.plist
  </files>
  <action>
Create NotificationPermissionView.swift:
- A SwiftUI view shown AFTER contact import completes in onboarding
- Takes two closures: `onEnable: () -> Void` and `onSkip: () -> Void`
- Layout: VStack with spacing 24, centered content
  - SF Symbol `bell.badge.fill` at size 64, `.foregroundStyle(.accent)`
  - Title: "Never Miss a Birthday" (.title2.bold())
  - Body text: "Get notified the day before and the day of each birthday so you always have time to prepare." (.multilineTextAlignment(.center), .foregroundStyle(.secondary))
  - "Enable Notifications" button with `.buttonStyle(.borderedProminent)` calling onEnable
  - "Maybe Later" button with `.foregroundStyle(.secondary)` calling onSkip
- Wrap in `.padding()` and add `.padding(.horizontal)` for comfortable margins

Update OnboardingFlowView.swift:
- Add a new case `.notificationPermission` to the OnboardingStep enum (between importing and complete)
- After the import step completes (where it currently sets `hasCompletedOnboarding = true`), transition to `.notificationPermission` instead
- In the switch, render NotificationPermissionView for `.notificationPermission`:
  - onEnable: Create a NotificationScheduler instance, call `await scheduler.requestPermission()`. Then if permission was granted, fetch all Person records from the model context and call `await scheduler.reschedule(people:deliveryHour:deliveryMinute:)` with defaults (hour: 9, minute: 0). Finally set `hasCompletedOnboarding = true`.
  - onSkip: Set `hasCompletedOnboarding = true` directly (user can enable later in settings)
- The NotificationScheduler needs to be passed in or created locally. Since the app root will own one, accept it via init parameter: `let notificationScheduler: NotificationScheduler`. Pass it from OnboardingFlowView's init.

Update OnboardingFlowView init to accept `notificationScheduler: NotificationScheduler` parameter.

Update BirthdayRemindersApp.swift:
- Add `@preconcurrency import UserNotifications` at the top
- Add `private let notificationScheduler = NotificationScheduler()` as a property
- Add `private let notificationDelegate = NotificationDelegate()` as a property
- In init(), after ModelContainer setup, set `UNUserNotificationCenter.current().delegate = notificationDelegate`
- Add `@Environment(\.scenePhase) private var scenePhase` to the struct
- Add `.onChange(of: scenePhase)` modifier to the WindowGroup: when `newPhase == .active`, create a Task that:
  a. Fetches all Person records from the container's mainContext using `FetchDescriptor<Person>()`
  b. Reads delivery hour/minute from UserDefaults (keys "notificationHour" defaulting to 9, "notificationMinute" defaulting to 0)
  c. Calls `await notificationScheduler.reschedule(people:deliveryHour:deliveryMinute:)`
- Pass `notificationScheduler` to OnboardingFlowView
- Pass `notificationScheduler` to BirthdayListView (will be needed by Plan 02 for settings, but add the parameter now to avoid rewriting later -- BirthdayListView can accept and ignore it for now, or store it for the settings navigation)

Update Info.plist:
- Add `NSUserNotificationsUsageDescription` key with value: "Birthday Reminders sends notifications on and before birthdays so you never miss one."
  </action>
  <verify>
Verify file structure:
- NotificationPermissionView.swift exists with bell icon, title, body, enable/skip buttons
- OnboardingStep enum has .notificationPermission case
- OnboardingFlowView transitions: welcome -> permissionRequest -> importing -> notificationPermission -> complete
- BirthdayRemindersApp has scenePhase observer calling reschedule on .active
- BirthdayRemindersApp sets UNUserNotificationCenter delegate in init
- Info.plist contains NSUserNotificationsUsageDescription key
- NotificationScheduler instance is shared between app root and onboarding
  </verify>
  <done>
Pre-permission primer screen appears after contact import in onboarding. Tapping "Enable" triggers the system notification prompt; tapping "Skip" proceeds without notifications. On every app foreground, the scheduler automatically reschedules all notifications sorted by proximity, capped at 64. NotificationDelegate is wired for foreground banner display. Info.plist includes notification usage description.
  </done>
</task>

</tasks>

<verification>
1. Onboarding flow: welcome -> contacts permission -> import -> notification primer -> birthday list (complete flow)
2. NotificationScheduler.reschedule produces at most 64 UNNotificationRequest objects with deterministic IDs
3. Day-before notifications for birthdays with target date in the past are skipped
4. ScenePhase .active triggers full reschedule with current Person data
5. NotificationDelegate set on UNUserNotificationCenter.current()
6. All notification content uses person.displayName, logged with privacy: .private
7. No deprecated APIs (.alert presentation option, UILocalNotification, completion-handler delegates)
8. Swift 6 compatibility: @preconcurrency import, nonisolated delegate methods
</verification>

<success_criteria>
- NotificationScheduler actor exists with reschedule method honoring the 64-notification ceiling
- NotificationDelegate displays foreground notifications as banners
- Pre-permission primer screen integrated into onboarding flow
- ScenePhase .active triggers automatic rescheduling
- Default delivery time of 9:00 AM used throughout
- Info.plist has NSUserNotificationsUsageDescription
</success_criteria>

<output>
After completion, create `.planning/phases/02-notification-engine/02-01-SUMMARY.md`
</output>
