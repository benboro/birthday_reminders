---
phase: 03-group-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - BirthdayReminders/Models/BirthdayGroup.swift
  - BirthdayReminders/Models/Person.swift
  - BirthdayReminders/Services/GroupSyncService.swift
  - BirthdayReminders/Services/NotificationScheduler.swift
  - BirthdayReminders/Services/ContactSyncService.swift
  - BirthdayReminders/App/BirthdayRemindersApp.swift
  - BirthdayReminders/Extensions/Logger+App.swift
autonomous: true

must_haves:
  truths:
    - "BirthdayGroup SwiftData model stores CNGroup identifier, name, and notification preference with many-to-many relationship to Person"
    - "GroupSyncService can create, rename, and delete groups in iOS Contacts via CNSaveRequest and sync them to SwiftData"
    - "GroupSyncService can add and remove contacts from groups in both iOS Contacts and SwiftData"
    - "NotificationScheduler respects per-group notification preferences when scheduling, with ungrouped contacts defaulting to both"
    - "Group sync runs during contact re-import so groups and membership stay current"
  artifacts:
    - path: "BirthdayReminders/Models/BirthdayGroup.swift"
      provides: "BirthdayGroup @Model with groupIdentifier, name, notificationPreference, members relationship"
      contains: "@Model"
    - path: "BirthdayReminders/Services/GroupSyncService.swift"
      provides: "CNGroup CRUD, membership management, bidirectional sync"
      contains: "CNSaveRequest"
    - path: "BirthdayReminders/Services/NotificationScheduler.swift"
      provides: "effectivePreference and per-group notification filtering"
      contains: "effectivePreference"
  key_links:
    - from: "BirthdayReminders/Models/BirthdayGroup.swift"
      to: "BirthdayReminders/Models/Person.swift"
      via: "@Relationship with inverse"
      pattern: "inverse.*Person\\.groups"
    - from: "BirthdayReminders/Services/NotificationScheduler.swift"
      to: "BirthdayReminders/Models/BirthdayGroup.swift"
      via: "effectivePreference reads person.groups"
      pattern: "person\\.groups"
    - from: "BirthdayReminders/Services/ContactSyncService.swift"
      to: "BirthdayReminders/Services/GroupSyncService.swift"
      via: "importContacts calls group sync"
      pattern: "syncGroups"
---

<objective>
Build the BirthdayGroup data model, GroupSyncService for bidirectional CNGroup sync, and extend NotificationScheduler to respect per-group notification preferences.

Purpose: Establishes the data layer and service layer for group management. Without this foundation, the UI (Plan 02) has nothing to display or mutate. Also integrates per-group notification preferences into the existing scheduler so the core value proposition (right notifications for the right people) works immediately.

Output: BirthdayGroup.swift model, GroupSyncService.swift service, modified Person.swift with groups relationship, modified NotificationScheduler.swift with per-group preference filtering, modified ContactSyncService.swift with group sync during import, updated ModelContainer schema.
</objective>

<execution_context>
@C:/Users/bmbor/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/bmbor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-group-management/03-RESEARCH.md
@.planning/phases/02-notification-engine/02-01-SUMMARY.md
@BirthdayReminders/Models/Person.swift
@BirthdayReminders/Services/NotificationScheduler.swift
@BirthdayReminders/Services/ContactSyncService.swift
@BirthdayReminders/App/BirthdayRemindersApp.swift
@BirthdayReminders/Extensions/Logger+App.swift
@BirthdayReminders/Models/ContactBridge.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: BirthdayGroup model, Person relationship, ModelContainer update, and Logger extension</name>
  <files>
    BirthdayReminders/Models/BirthdayGroup.swift
    BirthdayReminders/Models/Person.swift
    BirthdayReminders/App/BirthdayRemindersApp.swift
    BirthdayReminders/Extensions/Logger+App.swift
  </files>
  <action>
    Create BirthdayReminders/Models/BirthdayGroup.swift with:
    - NotificationPreference enum (String, Codable, CaseIterable) with cases: dayOfOnly ("Day of only"), dayBeforeOnly ("Day before only"), both ("Both")
    - @Model final class BirthdayGroup with:
      - @Attribute(.unique) var groupIdentifier: String (CNGroup.identifier)
      - var name: String
      - var notificationPreference: NotificationPreference (default .both)
      - @Relationship(deleteRule: .nullify, inverse: \Person.groups) var members: [Person]
      - init(groupIdentifier:name:notificationPreference:) that sets members = []

    Modify BirthdayReminders/Models/Person.swift:
    - Add `var groups: [BirthdayGroup] = []` property (bare array with default, no @Relationship macro needed -- BirthdayGroup declares the inverse)
    - Place it in a new `// MARK: - Groups` section after the birthday fields

    Modify BirthdayReminders/App/BirthdayRemindersApp.swift:
    - Update Schema to include BirthdayGroup.self: `Schema([Person.self, BirthdayGroup.self])`
    - Update ModelContainer for: `for: Person.self, BirthdayGroup.self`

    Modify BirthdayReminders/Extensions/Logger+App.swift:
    - Add `static let groups = Logger(subsystem: "com.birthdayreminders", category: "groups")` with SECR-04 privacy comment

    Note: SwiftData handles lightweight migration automatically for additive changes (new model, new properties with defaults). No VersionedSchema needed.
  </action>
  <verify>
    Project builds successfully (verify via syntax check -- no Xcode available on Windows). All files exist at expected paths. BirthdayGroup has @Model and @Relationship. Person has groups array. ModelContainer includes BirthdayGroup.self. Logger.groups category exists.
  </verify>
  <done>
    BirthdayGroup @Model exists with groupIdentifier, name, notificationPreference, and members relationship. Person has inverse groups array. ModelContainer schema includes BirthdayGroup. Logger has .groups category.
  </done>
</task>

<task type="auto">
  <name>Task 2: GroupSyncService, NotificationScheduler per-group preferences, and import integration</name>
  <files>
    BirthdayReminders/Services/GroupSyncService.swift
    BirthdayReminders/Services/NotificationScheduler.swift
    BirthdayReminders/Services/ContactSyncService.swift
  </files>
  <action>
    Create BirthdayReminders/Services/GroupSyncService.swift:
    - @MainActor final class GroupSyncService with private let store = CNContactStore()
    - func createGroup(name: String, context: ModelContext) throws -> BirthdayGroup
      - Creates CNMutableGroup, sets name, adds to default container (toContainerWithIdentifier: nil)
      - Executes CNSaveRequest, reads identifier AFTER execute
      - Creates BirthdayGroup in SwiftData with the CNGroup identifier
      - Logs via Logger.groups
    - func renameGroup(_ group: BirthdayGroup, to newName: String, context: ModelContext) throws
      - Fetches fresh CNGroup by identifier via store.groups(matching:) filtered by identifier
      - Creates mutableCopy, sets name, executes saveRequest.update
      - Updates group.name in SwiftData
    - func deleteGroup(_ group: BirthdayGroup, context: ModelContext) throws
      - Fetches fresh CNGroup by identifier
      - Creates mutableCopy, executes saveRequest.delete
      - Calls context.delete(group) for SwiftData removal (nullify rule preserves Person records)
    - func addMember(_ person: Person, to group: BirthdayGroup) throws
      - Fetches fresh CNGroup and CNContact by their identifiers
      - Executes saveRequest.addMember
      - Appends person to group.members (single append is fine for one-at-a-time user action)
    - func removeMember(_ person: Person, from group: BirthdayGroup) throws
      - Fetches fresh CNGroup and CNContact by their identifiers
      - Executes saveRequest.removeMember
      - Removes person from group.members
    - func syncGroupsFromContacts(context: ModelContext) throws
      - Fetches all CNGroups via store.groups(matching: nil) -- nil gets ALL containers
      - For each CNGroup: find or create BirthdayGroup by groupIdentifier, update name if changed
      - Remove stale BirthdayGroup records whose identifier no longer exists
      - For each BirthdayGroup: fetch CNContacts in group via predicateForContactsInGroup, match to Person by contactIdentifier, assign members array in one operation (not individual appends -- per research pitfall about 750x performance)
      - Log count of synced groups
    - Private helper: func fetchCNGroup(identifier: String) throws -> CNGroup? to re-fetch fresh CNGroup before mutations (avoids stale reference pitfall)
    - Private helper: func fetchCNContact(identifier: String) throws -> CNContact? to fetch contact for membership operations
    - Use ContactBridge.keysToFetch() when fetching contacts to avoid CNPropertyNotFetchedException

    Modify BirthdayReminders/Services/NotificationScheduler.swift:
    - Add func effectivePreference(for person: Person) -> NotificationPreference
      - If person.groups is empty, return .both (backward compatible -- ungrouped contacts keep current behavior)
      - If any group has .both, return .both
      - If groups contain both .dayOfOnly and .dayBeforeOnly across different groups, return .both (most permissive)
      - Otherwise return whichever single preference exists
    - Modify the reschedule loop to call effectivePreference(for: person) and filter:
      - Day-before: only if preference is .dayBeforeOnly or .both
      - Day-of: only if preference is .dayOfOnly or .both
    - Add `import SwiftData` at the top (needed for Person.groups access)
    - Keep all existing parameters and behavior (deliveryHour, deliveryMinute defaults, 64-cap logic, deterministic IDs)

    Modify BirthdayReminders/Services/ContactSyncService.swift:
    - Add a property: var groupSyncService: GroupSyncService? (optional, set externally)
    - At the end of importContacts (after ContactBridge.removeStale and context.save, before onImportComplete callback):
      - If groupSyncService is not nil, call try? groupSyncService.syncGroupsFromContacts(context: context)
      - Log group sync completion or error
    - This ensures group sync piggybacks on existing manual re-import pattern (per research recommendation #3)
  </action>
  <verify>
    All three files exist at expected paths. GroupSyncService has createGroup, renameGroup, deleteGroup, addMember, removeMember, and syncGroupsFromContacts methods. NotificationScheduler has effectivePreference method and the reschedule loop checks preference before scheduling each notification type. ContactSyncService calls group sync during import.
  </verify>
  <done>
    GroupSyncService provides full CNGroup CRUD and bidirectional sync. NotificationScheduler filters day-of/day-before notifications per group preference with ungrouped contacts defaulting to both. Contact import triggers group sync automatically.
  </done>
</task>

</tasks>

<verification>
1. BirthdayGroup.swift exists with @Model, @Attribute(.unique) groupIdentifier, @Relationship to Person
2. Person.swift has var groups: [BirthdayGroup] = [] property
3. BirthdayRemindersApp.swift ModelContainer schema includes BirthdayGroup.self
4. GroupSyncService.swift has all CRUD methods and syncGroupsFromContacts
5. NotificationScheduler.swift has effectivePreference method and per-group filtering in reschedule
6. ContactSyncService.swift calls groupSyncService.syncGroupsFromContacts during import
7. Logger+App.swift has .groups category
</verification>

<success_criteria>
- BirthdayGroup model persists with CNGroup identifier linkage and notification preference
- Person has many-to-many relationship to BirthdayGroup
- Groups can be created, renamed, and deleted in both iOS Contacts and SwiftData
- Contacts can be added to and removed from groups in both stores
- All iOS Contacts groups appear in SwiftData after sync
- NotificationScheduler respects per-group preferences (dayOfOnly, dayBeforeOnly, both)
- Ungrouped contacts default to .both (backward compatible with Phase 2 behavior)
- Group sync runs automatically during contact import
</success_criteria>

<output>
After completion, create `.planning/phases/03-group-management/03-01-SUMMARY.md`
</output>
